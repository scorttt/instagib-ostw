import "main.del";

// will have weird alignment for aspect ratios other than 16:9
Vector FacingTextLocation(in Number X, in Number Y): 
Update(EyePosition(local) + 100 * 
          (X * WorldVectorOf(Right(), local, LocalVector.Rotation) + // X
          (Y // Y
          - 0.200) * DirectionFromAngles(HorizontalAngleFromDirection(Facing(local)), VerticalAngleFromDirection(Facing(local)) - 90) +
          3 * Facing(local)));

// Boolean VisibilityCheck(Number modIndex): 
//     IsInLineOfSight(EyePos(local), modPos[Once(modIndex)]) &&
//     IsInViewAngle(local, modPos[Once(modIndex)], 62) && 
//     DistanceBetween(EyePos(local), modPos[Once(modIndex)]) < 50;

Number orangeThreshold: (20 - MIN_SPEED) / (27 - MIN_SPEED);
Number redThreshold: (22.5 - MIN_SPEED) / (27 - MIN_SPEED);
Number purpleThreshold: (27 - MIN_SPEED) / (27 - MIN_SPEED);
Number threshold: Max(0, Min(1, (HorizontalSpeedOf(local) - MIN_SPEED) / (27 - MIN_SPEED)));
Color speedColor: 
    CustomColor(
        // r
        threshold < orangeThreshold ? 255 : 
        threshold < redThreshold ? 255 : 
        Near(255 - ((threshold - redThreshold) / (purpleThreshold - redThreshold)) * 95),

        // g
        threshold < orangeThreshold ? Near(255 - (threshold / orangeThreshold) * 90) : 
        threshold < redThreshold ? Near(165 - ((threshold - orangeThreshold) / (redThreshold - orangeThreshold)) * 165) : 
        Near(((threshold - redThreshold) / (purpleThreshold - redThreshold)) * 80),

        // b
        threshold < orangeThreshold ? Near(255 - (threshold / orangeThreshold) * 255) : 
        threshold < redThreshold ? 0 : 
        Near(((threshold - redThreshold) / (purpleThreshold - redThreshold)) * 180),

        255);


Number replenishFlashStartTime: local.fuelReplenishFlashStartTime;
Number timeSinceReplenishFlash: Time() - replenishFlashStartTime;
Number replenishFadeAmount: timeSinceReplenishFlash / 1;
Color fuelGreenFlash: CustomColor(
    replenishFadeAmount * 255,
    255,
    replenishFadeAmount * 255,
    255);

Number depletionFlashStartTime: local.fuelDepletionFlashStartTime;
Number timeSinceDepletionFlash: Time() - depletionFlashStartTime;
Number depletionFadeAmount: timeSinceDepletionFlash / 1;

Color fuelRedFlash: CustomColor(
    255,
    depletionFadeAmount * 255,
    depletionFadeAmount * 255,
    255);

rule: "[Main] :: General HUD Text"
{
    // left spacer 
    CreateHudText(All(), null, null, " \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n", Location.Left, 0.1);

    // time
    CreateHudText(All(), null, <"<0>:<1><2>", Floor(MatchTime() / 60 % 60), 
                                MatchTime() % 60 < 10 ? "0" : "", 
                                Floor(MatchTime() % 60)>,
    " \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n", Location.Top, 0.1);

    // speedometer
    // CreateHudText(local, null, <"<0>", HorizontalSpeedOf(local) + 0.001>,
    // null, Location.Top, 0.2, Color.White, speedColor, Color.White, HudTextRev.VisibleToSortOrderStringAndColor);

    CreateInWorldText(local, <"<0>", HorizontalSpeedOf(local) + 0.001>,
    FacingTextLocation(0, -0.09), 1.2, Clipping.DoNotClip, InworldTextRev.VisibleToPositionStringAndColor, speedColor);

    // if (S_JETPACK_ENABLED)
    {
        // jetpack fuel, not a hud text since i would have to adjust ammo text spacing which frequently changes in gameplay
        // this will not show correctly on 21:9 monitors
        CreateProgressBarInWorldText(IsAlive(local) ? local : null, local.fuel * 100, 
        !local.infFuel ? <String>Near(local.fuel * 100) : "∞",
        FacingTextLocation(-2.6, -1.35), 
        0, Clipping.DoNotClip, 
        local.isFlying
            ? CustomColor(255, PingPong(1500, 255), PingPong(1500, 255), 255)
            : local.fuel == 1
                ? fuelGreenFlash
                : local.fuelDepletionFlashTriggered
                    ? fuelRedFlash
                : Color.White,
        Color.White,
        ProgressBarWorldEvaluation.VisibleToPositionValuesAndColor);

        CreateInWorldText(IsAlive(local) ? local : null, "Fuel", FacingTextLocation(-2.97, -1.1), 0.75, Clipping.DoNotClip, InworldTextRev.VisibleToAndPosition, Color.White);

        CreateInWorldText(IsAlive(local) ? local : null, AbilityIconString(Hero.Torbjorn, Button.Ultimate), FacingTextLocation(-3.08, -1.13), 1.5, Clipping.DoNotClip, InworldTextRev.VisibleToAndPosition, Color.White);
    }
}

Color CanPlayerPickupModColor(Number index): 
    local.playerHasMod && 
        (local.currentModIdx != Once(index) || local.infAmmo)
        ? Color.Gray : MOD_COLORS[Once(index)];

rule: "[Main] :: Pickup HUD Text and Effects : Welcome to hell"
if (validMap)
if (S_ENABLE_MODS)
{
    for (Number i! = 0; i < MOD_NAMES.Length; i++)
    {
        if (S_SPAWN_MOD[i])
        {
            // ammo
            CreateHudText(
                VisibleTo:        local.modEnabled[Once(i)] ? local : null,
                Header:           null,
                Subheader:        null,
                Text:             <"<0> <1> Ammo: <2>",
                                        MOD_ICONS[Once(i)], 
                                        MOD_NAMES[Once(i)], 
                                        !local.infAmmo ? 
                                            !local.showAmmoAsPercentage ? 
                                                Ceil(local.heldModAmmo[Once(i)]) 
                                            : <"<0>%", Ceil(Ceil(local.heldModAmmo[Once(i)]) / S_MOD_AMMO[Once(i)] * 100)>
                                        : "∞">, 
                Location:         Location.Left, 
                SortOrder:        1, 
                TextColor:        MOD_COLORS[Once(i)], 
                Reevaluation:     HudTextRev.VisibleToSortOrderStringAndColor);

            // complete orb effect
            CreateEffect(
                VisibleTo:        modCooldown[Once(i)] == 0 ? local : null, 
                Type:             Effect.BadAura, 
                Color:            CanPlayerPickupModColor(i), 
                Position:         modPos[Once(i)], 
                Radius:           0.45, 
                Reevaluation:     EffectRev.VisibleToAndColor);

            // complete text
            CreateInWorldText(
                VisibleTo:        modCooldown[Once(i)] == 0 ? local : null, 
                Header:           " \n\n\n" + MOD_ICONS[Once(i)], 
                Position:         modPos[Once(i)] + Vector(0, 0.085, 0),
                Scale:            2.1, 
                Clipping:         Clipping.ClipAgainstSurfaces, 
                Reevaluation:     InworldTextRev.VisibleToAndPosition);

            // completed/in-progress good aura effect
            CreateEffect(
                VisibleTo:        local, 
                Type:             Effect.GoodAura, 
                Color:            CanPlayerPickupModColor(i),
                Position:         modPos[Once(i)], 
                Radius:           modPickupEffectSize[Once(i)],
                Reevaluation:     EffectRev.VisibleToPositionRadiusAndColor);

            // completed/in-progress sparkle effect
            CreateEffect(
                VisibleTo:        local, 
                Type:             Effect.Sparkles, 
                Color:            CanPlayerPickupModColor(i),
                Position:         modPos[Once(i)], 
                Radius:           modPickupEffectSize[Once(i)],
                Reevaluation:     EffectRev.VisibleToPositionRadiusAndColor);

            // in progress sphere effect
            CreateEffect(
                VisibleTo:        modCooldown[Once(i)] != 0 ? local : null, 
                Type:             Effect.Sphere, 
                Color:            CanPlayerPickupModColor(i), 
                Position:         modPos[Once(i)], 
                Radius:           modPickupEffectSize[Once(i)],
                Reevaluation:     EffectRev.VisibleToPositionRadiusAndColor);
    
            // in progress progress bar
            // CreateProgressBarInWorldText(
            //     VisibleTo:        modCooldown[Once(i)] != 0 ? local : null, 
            //     Value:            modPickupEffectSize[Once(i)], 
            //     Text:             null, 
            //     Position:         modPos[Once(i)] + Vector(0, modPickupEffectSize[Once(i)] * 0.0045, 0),
            //     Scale:            0, 
            //     Clipping:         Clipping.ClipAgainstSurfaces, 
            //     ProgressBarColor: MOD_COLORS[Once(i)], 
            //     TextColor:        Color.White, 
            //     Reevaluation:     ProgressBarWorldEvaluation.VisibleToPositionValuesAndColor);

            // in progress timer text
            CreateInWorldText(
                VisibleTo:        modCooldown[Once(i)] != 0 ? local : null, 
                Header:           modCooldown[Once(i)] >= 60 
                                        ? <"<0>:<1><2>", 
                                            Floor(modCooldown[Once(i)] / 60 % 60), 
                                            modCooldown[Once(i)] % 60 < 10 
                                                ? "0" 
                                                : "", 
                                            Floor(modCooldown[Once(i)] % 60)> 
                                        : Floor(modCooldown[Once(i)]), 
                Position:         modPos[Once(i)],
                Scale:            1.5, 
                Clipping:         Clipping.ClipAgainstSurfaces, 
                TextColor:        Color.White, 
                Reevaluation:     InworldTextRev.VisibleToPositionAndString);
        }
    }

    // buckshot
    if (S_SPAWN_MOD[Mod.Buckshot])
    {
        // alt fire
        CreateHudText(local.modEnabled[Mod.Buckshot] ? local : null, null, 
        <"<0>: Charge shots", InputBindingString(Button.Reload)>, null,
        Location.Left, 1.1, SubheaderColor: MOD_COLORS[Mod.Buckshot]);

        // charge
        CreateHudText(local.modEnabled[Mod.Buckshot] ? local : null, null,  
        <" Charges: <0>", local.chargeStr>, null,
        Location.Left, 1.2, SubheaderColor: MOD_COLORS[Mod.Buckshot]);
    }

    // prism
    if (S_SPAWN_MOD[Mod.Prism])
    {
        // alt fire
        CreateHudText(local.modEnabled[Mod.Prism] ? local : null, null,
        <"<0>: Alternate fire", InputBindingString(Button.Reload)>, null,
        Location.Left, 1.1, SubheaderColor: MOD_COLORS[Mod.Prism]);
    }

    // electro
    if (S_SPAWN_MOD[Mod.Electro])
    {
        // alt fire
        CreateHudText(local.modEnabled[Mod.Electro] ? local : null, null, 
        <"<0>: Alternate fire", InputBindingString(Button.Reload)>, null,
        Location.Left, 1.1, SubheaderColor: MOD_COLORS[Mod.Electro]);

        // armed
        CreateHudText(local.totalProjAirtime != 0 ? local : null, null,  
        AltFont(<"Detonation in: <0>", local.projHitSurface ? Max(S_ELECTRO_PROJ_DELAY - local.airtime, 0.001) : Max(FINAL_PROJ_DELAY - local.totalProjAirtime, 0.001)>), null,
        Location.Left, 1.2, SubheaderColor: local.projHitSurface || local.totalProjAirtime > 1 ? Color.Red : MOD_COLORS[5], Reevaluation: HudTextRev.VisibleToSortOrderStringAndColor);
    }

    // spark
    if (S_SPAWN_MOD[Mod.Spark])
    {
        // alt fire
        CreateHudText(local.modEnabled[Mod.Spark] ? local : null, null, 
        <"<0>: Alternate fire", InputBindingString(Button.Reload)>, null,
        Location.Left, 1.1, SubheaderColor: MOD_COLORS[Mod.Spark]);
    }

    // volt
    if (S_SPAWN_MOD[Mod.Volt])
    {
        // temperature
        CreateProgressBarHudText(local.modEnabled[Mod.Volt] ? local : null, 
        local.voltTemp * 100, !local.overheated ? <"<0>%", Floor(Clamp(local.voltTemp * 100 + (local.voltTemp * (Time() + 1000)) % 8, 0, 99))> : "Overheat",
        Location.Left, 1.2, 
        CustomColor(
            Lerp(255, 255, local.voltTemp), // r
            Lerp(100, 0, local.voltTemp),  // g
            Lerp(0, 0, local.voltTemp),  // b
            255), 
        CustomColor(
            Lerp(255, 255, local.voltTemp), // r
            Lerp(100, 0, local.voltTemp),  // g
            Lerp(0, 0, local.voltTemp),  // b
            255), 
        ProgressBarHudEvaluation.VisibleToValuesAndColor);
    }

    // buffs
    if (S_ENABLE_BUFFS)
    {
        // buff info
        // CreateHudText(
        //     isBuffInWorld || buffUser != null ? RemoveFromArray(All(), buffUser) : null, 
        //     buffIcon, 
        //     buffStr, 
        //     buffProgressBar != 100 && buffCooldown <= S_BUFF_CREATION 
        //         ? <"<0>%", Floor(buffProgressBar)> 
        //         : !IsTrueForAny(All(), Curr().playerHasBuff) 
        //             ? IconString(Icon.Checkmark)
        //             : <"In-use by <0>", buffUser>,
        //     Location.Left, 
        //     24, 
        //     buffColors[0], 
        //     buffColors[0], 
        //     Reevaluation: HudTextRev.VisibleToSortOrderStringAndColor);

        // icon
        CreateInWorldText(local.playerHasBuff ? local : null, 
        buffIcon, 
        FacingTextLocation(-0.65, -1.028), 
        1.2, 
        Clipping.DoNotClip, InworldTextRev.VisibleToPositionStringAndColor, 
        buffColors[0]);

        // text
        CreateInWorldText(local.playerHasBuff ? local : null, 
        buffStr,
        FacingTextLocation(0, -0.93), 
        1.75, 
        Clipping.DoNotClip, InworldTextRev.VisibleToPositionStringAndColor, 
        buffColors[0]);

        // progress bar
        CreateProgressBarInWorldText(local.playerHasBuff ? local : null, local.buffNormalTimeLeft, 
        null,
        FacingTextLocation(0, -1.235), 
        0.65, Clipping.DoNotClip, 
        buffColors[1], 
        null,
        ProgressBarWorldEvaluation.VisibleToPositionValuesAndColor);

        // ability text
        CreateInWorldText(local.playerHasBuff ? local : null, 
        StringReplace(BUFF_DESCRIPTIONS[chosenBuff], "*", InputBindingString(local.abilityButton)),
        FacingTextLocation(0, -1.125), 
        1, 
        Clipping.DoNotClip, InworldTextRev.VisibleToPositionStringAndColor, 
        buffColors[0]);

        // buff spawning
        CreateProgressBarInWorldText(isBuffInWorld && buffProgressBar != 100 ? local : null, buffProgressBar, null, buffPos + Vector(0, buffProgressBar * 0.0045, 0), 0, Clipping.DoNotClip, buffColors[0], null, ProgressBarWorldEvaluation.VisibleToPositionValuesAndColor);
        CreateIcon(isBuffInWorld && !IsInViewAngle(local, buffPos, 52) ? local : null, buffPos - Vector(0, 1.5, 0), Icon.ExclamationMark, IconRev.VisibleToPositionAndColor, buffColors[0], true);
        CreateEffect(isBuffInWorld ? local : null, Effect.BadAura, buffColors[1], buffPos, buffProgressBar * 0.0045, EffectRev.VisibleToPositionRadiusAndColor);
        CreateEffect(isBuffInWorld ? local : null, Effect.GoodAura, buffColors[0], buffPos, buffProgressBar * 0.0045, EffectRev.VisibleToPositionRadiusAndColor);
        CreateEffect(isBuffInWorld ? local : null, Effect.Sparkles, buffColors[0], buffPos, buffProgressBar * 0.0045, EffectRev.VisibleToPositionRadiusAndColor);

        // buff spawned
        CreateInWorldText(isBuffInWorld && buffProgressBar == 100 ? local : null, " \n\n\n" + buffIcon, buffPos + Vector(0, 0.085, 0), 2.1, Clipping.DoNotClip, InworldTextRev.VisibleToPositionAndString);
    }
}